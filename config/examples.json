[
  {
    "id": 124,
    "user_id": 1,
    "input": "from = User.find!(\"dorian\")\nhandles = [\"dorian\"]\nlimit = 20\n\nids_response = Http.get(\"https://hacker-news.firebaseio.com/v0/topstories.json\")\nids = Json.parse(ids_response.body).first(limit)\n\nitems = ids.map do |id|\n  Json.parse(Http.get(\"https://hacker-news.firebaseio.com/v0/item/{id}.json\").body)\nend\n\nsubject = \"hn {Date.today}\"\nbody = items.map do |item|\n  if item[\"url\"]\n    '<p><a href=\"{item.url}\">{item.title}</a></p>'\n  else\n    '<p>{item.title}</p>'\n  end\nend.join\n\nhandles.each do |handle|\n  to = User.find(handle)\n\n  next unless to\n\n  message = Message.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    body: body,\n  )\n\n  Notification.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    path: \"/users/{to.id}/messages/{message.id}/body\",\n    sound: :default,\n    thread_id: :hn,\n    collapse_key: :hn,\n  )\nend\n\n\"hn {Date.today}\"",
    "created_at": "2025-09-06T12:12:35.317Z",
    "updated_at": "2025-09-12T07:00:31.983Z",
    "name": "dorian: hn"
  },
  {
    "id": 127,
    "user_id": 1,
    "input": "from = User.find!(\"dorian\")\nhandles = [\"dorian\"]\nopen_ai_api_key = Datum.value!(\"open_ai_api_key\")\nmodel = Datum.value!(\"model\")\n\nresponse = Http.post(\n  \"https://api.openai.com/v1/chat/completions\",\n  headers: {\n    authorization: \"Bearer {open_ai_api_key}\",\n    \"content-type\": \"application/json\"\n  },\n  body: {\n    model: model,\n    messages: [\n      { role: :system, content: \"give me a random fun fact in french\" },\n      { role: :system, content: \"random seed {(1..100_000).sample}\" },\n    ],\n  }.to_json,\n)\n\nsubject = \"fact {Date.today}\"\nbody = Json.parse(response.body).choices.first.message.content\n\nhandles.each do |handle|\n  to = User.find(handle)\n\n  next unless to\n\n  message = Message.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    body: body\n  )\n\n  Notification.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    body: body,\n    path: \"/users/{to.id}/messages/{message.id}/body\",\n    sound: :default,\n    thread_id: :fact,\n    collapse_key: :fact\n  )\nend\n\nsubject",
    "created_at": "2025-09-06T12:39:24.043Z",
    "updated_at": "2025-09-12T07:01:05.099Z",
    "name": "dorian: fact"
  },
  {
    "id": 115,
    "user_id": 1,
    "input": "from = User.find!(\"dorian\")\nhandles = [\"vincent\"]\nreddit_username = Datum.value!(\"reddit_username\")\nreddit_password = Datum.value!(\"reddit_password\")\nreddit_client_id = Datum.value!(\"reddit_client_id\")\nreddit_client_secret = Datum.value!(\"reddit_client_secret\")\nuser_agent = \"codedorian.com 1.0\"\nlimit = 100\nsubreddits = [\n  :france,\n  :rance,\n  :memesFR,\n  :dinosaure,\n  :memefrancais,\n  :frenchmemes,\n]\ntime = :day\n\ntoken_response = Http.post(\n  \"https://www.reddit.com/api/v1/access_token\",\n  headers: { \"user-agent\": user_agent },\n  username: reddit_client_id,\n  password: reddit_client_secret,\n  data: {\n    grant_type: :password,\n    username: reddit_username,\n    password: reddit_password,\n  },\n)\ntoken_body = token_response.body\ntoken_json = Json.parse(token_body)\ntoken = token_json.access_token\n\nsubreddits.each do |subreddit|\n  subject = \"reddit {subreddit} {Date.today}\"\n  subreddit_response = Http.get(\n    \"https://oauth.reddit.com/r/{subreddit}/top\",\n    headers: {\n      \"authorization\": \"bearer {token}\",\n      \"user-agent\": user_agent,\n    },\n    query: {\n      limit: limit,\n      t: time,\n    },\n  )\n  subreddit_body = subreddit_response.body\n  subreddit_json = Json.parse(subreddit_body)\n  subreddit_children = subreddit_json&.data&.children\n  subreddit_images = subreddit_children&.select do |subreddit_child|\n    subreddit_child.dig(:data, :post_hint) == :image\n  end\n  reddit_posts = subreddit_images&.map(&:data)&.map do |subreddit_post|\n    {\n      title: subreddit_post.title,\n      url: subreddit_post.url\n    }\n  end\n\n  body = reddit_posts.map do |reddit_post|\n    '\n      <p>\n        <a href=\"{reddit_post.url}\">\n          {reddit_post.title}\n        </a>\n      </p>\n\n      <p>\n        <a href=\"{reddit_post.url}\">\n          <img alt=\"{reddit_post.title}\" src=\"{reddit_post.url}\" />\n        </a>\n      </p>\n    '\n  end.join(\"<br>\")\n\n  handles.each do |handle|\n    to = User.find(handle)\n\n    next unless to\n\n    message = Message.create!(\n      from: from,\n      to: to,\n      subject: subject,\n      body: body,\n    )\n\n\n    Notification.create!(\n      from: from,\n      to: to,\n      subject: subject,\n      path: \"/users/{to.id}/messages/{message.id}/body\",\n      sound: :default,\n      thread_id: :reddit,\n      collapse_key: :reddit,\n    )\n  end\nend\n\n\"reddit {Date.today}\"\n",
    "created_at": "2025-08-28T17:12:10.660Z",
    "updated_at": "2025-09-12T07:00:15.290Z",
    "name": "vincent: reddit"
  },
  {
    "id": 120,
    "user_id": 1,
    "input": "from = User.find!(\"dorian\")\nhandles = [\"dorian\"]\nopen_ai_api_key = Datum.value!(\"open_ai_api_key\")\nmodel = Datum.value!(\"model\")\n\nresponse = Http.post(\n  \"https://api.openai.com/v1/chat/completions\",\n  headers: {\n    authorization: \"Bearer {open_ai_api_key}\",\n    \"content-type\": \"application/json\"\n  },\n  body: {\n    model: model,\n    messages: [\n      { role: :system, content: \"give me a random quote in french, only the quote\" },\n      { role: :system, content: \"random seed {(1..100_000).sample}\" },\n    ],\n  }.to_json,\n)\n\nsubject = \"citation {Date.today}\"\nbody = Json.parse(response.body).choices.first.message.content\n\nhandles.each do |handle|\n  to = User.find(handle)\n  next unless to\n\n  message = Message.create!(from: from, to: to, subject: subject, body: body)\n\n  Notification.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    body: body,\n    path: \"/users/{to.id}/messages/{message.id}/body\",\n    sound: :default,\n    thread_id: :quote,\n    collapse_key: :quote,\n  )\nend\n\nsubject",
    "created_at": "2025-09-03T19:01:15.885Z",
    "updated_at": "2025-09-12T07:00:23.703Z",
    "name": "dorian: quote"
  },
  {
    "id": 119,
    "user_id": 1,
    "input": "from = User.find!(:dorian)\nhandles = [:dorian]\ncountries = [:us]\nnews_api_key = Datum.value!(:news_api_key)\nlimit = 20\n\ncountries.each do |country|\n  response = Http.get(\n    \"https://newsapi.org/v2/top-headlines\",\n    headers: { \"x-api-key\": news_api_key },\n    query: {\n      country: country,\n      pageSize: limit,\n    },\n  )\n  \n  json = Json.parse(response.body)\n  articles = json.articles\n  \n  subject = \"news {country} {Date.today}\"\n  \n  body = articles.map do |article|\n    title = article.title\n    url = article.url\n    image = article.urlToImage\n    source = article.source.name\n  \n    '\n      <p>\n        <a href=\"{url}\">{title}</a>\n        <br>\n        <small>{source}</small>\n      </p>\n      {image ? '<p><a href=\"{url}\"><img src=\"{image}\" /></a></p>' : \"\"}\n    '\n  end.join(\"<br>\")\n  \n  handles.each do |handle|\n    to = User.find(handle)\n    next unless to\n  \n    message = Message.create!(\n      from: from,\n      to: to,\n      subject: subject,\n      body: body,\n    )\n  \n    Notification.create!(\n      from: from,\n      to: to,\n      subject: subject,\n      path: \"/users/{to.id}/messages/{message.id}/body\",\n      sound: :default,\n      thread_id: :news,\n      collapse_key: :news,\n    )\n  end\nend\n\n\"news {Date.today}\"",
    "created_at": "2025-09-02T19:42:44.493Z",
    "updated_at": "2025-09-12T07:01:10.603Z",
    "name": "dorian: news"
  },
  {
    "id": 131,
    "user_id": 1,
    "input": "from = User.find!(\"dorian\")\nhandles = [\"dorian\"]\n\ncountry = :fr\nmonths_ahead = 1\n\nyears = [Date.year, Date.year + 1]\n\nholidays = years.map do |year|\n  response = Http.get(\"https://date.nager.at/api/v3/PublicHolidays/{year}/{country}\")\n  Json.parse(response.body)\nend.flatten\n\ntoday = Date.today\nlimit_date = today.add(months: months_ahead)\n\nupcoming = holidays.select do |holiday|\n  date = Date.new(holiday.date)\n  date >= today and date <= limit_date\nend.sort { |holiday| Date.new(holiday.date) }\n\nsubject = \"holidays {Date.today}\"\n\nmessage_body = \"<ul>{upcoming.map do |holiday|\n  \"<li>{holiday.date}: {holiday.localName} ({holiday.name})</li>\"\nend.join}</ul>\"\n\nnotification_body = upcoming.one? ? \"1 holiday upcoming\" : \"{upcoming.size} holidays upcoming\"\n\nhandles.each do |handle|\n  to = User.find(handle)\n  next unless to\n\n  message = Message.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    body: message_body,\n  )\n\n  Notification.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    body: notification_body,\n    path: \"/users/{to.id}/messages/{message.id}/body\",\n    sound: :default,\n    thread_id: :holidays,\n    collapse_key: :holidays,\n  )\nend\n\n\"holidays {Date.today}\"\n",
    "created_at": "2025-09-09T19:05:29.090Z",
    "updated_at": "2025-09-12T07:00:04.765Z",
    "name": "dorian: holidays"
  },
  {
    "id": 121,
    "user_id": 1,
    "input": "from = User.find!(\"dorian\")\nhandles = [\"dorian\"]\nopen_ai_api_key = Datum.value!(\"open_ai_api_key\")\nmodel = Datum.value!(\"model\")\n\nresponse = Http.post(\n  \"https://api.openai.com/v1/chat/completions\",\n  headers: {\n    authorization: \"Bearer {open_ai_api_key}\",\n    \"content-type\": \"application/json\"\n  },\n  body: {\n    model: model,\n    messages: [\n      { role: :system, content: \"give me a random joke in french, only the joke\" },\n      { role: :system, content: \"random seed {(1..100_000).sample}\" },\n    ],\n  }.to_json,\n)\n\nsubject = \"blague {Date.today}\"\nbody = Json.parse(response.body).choices.first.message.content\n\nhandles.each do |handle|\n  to = User.find(handle)\n  next unless to\n\n  message = Message.create!(from: from, to: to, subject: subject, body: body)\n\n  Notification.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    body: body,\n    path: \"/users/{to.id}/messages/{message.id}/body\",\n    sound: :default,\n    thread_id: :joke,\n    collapse_key: :joke,\n  )\nend\n\nsubject",
    "created_at": "2025-09-03T19:03:35.614Z",
    "updated_at": "2025-09-12T07:00:20.339Z",
    "name": "dorian: joke"
  },
  {
    "id": 117,
    "user_id": 1,
    "input": "from = User.find!(\"dorian\")\nhandles = [\"dorian\"]\n\nsend! = (subject:) => {\n  handles.each do |handle|\n    to = User.find(handle)\n\n    next unless to\n\n    Notification.create!(\n      from: from,\n      to: to,\n      subject: subject,\n      sound: :default,\n      thread_id: :pomodoro,\n      collapse_key: :pomodoro,\n    )\n  end\n\n  subject\n}\n\nif Time.hour >= 6 and Time.hour < 23\n  if Time.minutes < 5\n    send!(subject: \"pomodoro start {Time.hour}:00\")\n  elsif Time.minutes >= 25 and Time.minutes < 30\n    send!(subject: \"pomodoro break {Time.hour}:25\")\n  elsif Time.minutes >= 30 and Time.minutes < 35\n    send!(subject: \"pomodoro start {Time.hour}:30\")\n  elsif Time.minutes >= 55\n    send!(subject: \"pomodoro break {Time.hour}:55\")\n  else\n    \"pomodoro {Time.now}\"\n  end\nelse\n  \"not pomodoro {Time.now}\"\nend\n",
    "created_at": "2025-09-01T18:06:16.990Z",
    "updated_at": "2025-09-12T18:20:08.538Z",
    "name": "dorian: pomodoro"
  },
  {
    "id": 58,
    "user_id": 1,
    "input": "from = User.find!(\"dorian\")\n\nhandles = [\"grandma\"]\n\nresponse = Http.get(\"https://www.ktotv.com/guide/\")\n\npage = Html.new(response.body)\n\nelements = page.css(\"#tab{Date.today} .programming-scroll ul > li:has(.date)\")\n\nsubject = \"kto {Date.today}\"\nbody = elements.map do |element|\n  \"{Time.new(\"{Date.today} {element.css(\".date\")}\").format(\"%H:%M\")}: {element.css(\"h5\")}\"\nend.compact.join(\"<br>\")\n\nhandles.each do |handle|\n  to = User.find(handle)\n\n  next unless to\n\n  message = Message.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    body: body,\n  )\n\n  Notification.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    path: \"/users/{to.id}/messages/{message.id}/body\",\n    sound: :default,\n    thread_id: :kto,\n    collapse_key: :kto,\n  )\nend\n\nsubject\n",
    "created_at": "2025-05-16T19:15:22.583Z",
    "updated_at": "2025-09-12T04:00:09.214Z",
    "name": "grandma: kto"
  },
  {
    "id": 67,
    "user_id": 1,
    "input": "names = [\n  :arthur,\n  :baptiste,\n  :dorian,\n  :fabien,\n  :marine,\n  :mathieu,\n  :vincent,\n]\n\nnames = names.shuffle\n\nsubject = \"all hands {Date.today}\"\nmessage = \"{subject}\\n\\nfirst to be available:\\n\\n{names.join(\"\\n\")}\"\n\nslack_bot_user_oauth_token = Datum.value!(\"slack_bot_user_oauth_token\")\nslack_channel_id = Datum.value!(\"slack_channel_id_tech\")\n\nHttp.post(\n  \"https://slack.com/api/chat.postMessage\",\n  headers: {\n    \"content-type\": \"application/json; charset=utf-8\",\n    \"authorization\": \"Bearer {slack_bot_user_oauth_token}\",\n  },\n  body: { channel: slack_channel_id, text: message }.to_json\n)\n\nsubject",
    "created_at": "2025-05-27T07:24:48.059Z",
    "updated_at": "2025-09-10T05:24:05.430Z",
    "name": "workelo: hands"
  },
  {
    "id": 57,
    "user_id": 1,
    "input": "names = [\n  :alex,\n  :arthur,\n  :baptiste,\n  :dorian,\n  :fabien,\n  :louis,\n  :marine,\n  :mathieu,\n  :simon,\n  :vincent,\n]\n\nnames = names.shuffle\n\nsubject = \"daily {Date.today}\"\nmessage = \"{subject}\\n\\n{names.join(\"\\n\")}\"\n\nslack_bot_user_oauth_token = Datum.value!(\"slack_bot_user_oauth_token\")\nslack_channel_id = Datum.value!(\"slack_channel_id_product_tech\")\n\nif Time.monday? or Time.tuesday? or Time.wednesday? or Time.thursday? or Time.friday?\n  Http.post(\n    \"https://slack.com/api/chat.postMessage\",\n    headers: {\n      \"content-type\": \"application/json; charset=utf-8\",\n      \"authorization\": \"Bearer {slack_bot_user_oauth_token}\",\n    },\n    body: { channel: slack_channel_id, text: message }.to_json\n  )\nend\n\nsubject",
    "created_at": "2025-05-16T18:53:13.419Z",
    "updated_at": "2025-09-12T07:00:04.641Z",
    "name": "workelo: daily"
  },
  {
    "id": 114,
    "user_id": 1,
    "input": "from = User.find!(\"dorian\")\nhandles = [\"vincent\"]\nserp_api_key = Datum.value!(\"serp_api_key\")\n\nsuffixes = [\n  \"\",\n  :absurde,\n  :beauf,\n  :bouseux,\n  :gras,\n  :lourd,\n  :lourdingue,\n  :noir,\n  :potache,\n  :vache,\n  :morbide,\n]\n\nsuffixes.each do |suffix|\n  if suffix == \"\"\n    q = \"humour\"\n  else\n    q = \"humour {suffix}\"\n  end\n\n  subject = \"google {q} {Date.today}\"\n\n  search_response = Http.get(\n    \"https://serpapi.com/search.json\",\n    query: {\n      q: 'humour {q} {(1..100_000).sample}',\n      engine: :google_images,\n      api_key: serp_api_key,\n      hl: :fr\n    },\n  )\n\n  search_body = search_response.body\n  search_json = Json.parse(search_body)\n  search_images_results = search_json.images_results\n\n  body = search_images_results.map do |search_image_result|\n    '\n      <p>\n        <a href=\"{search_image_result.link}\">\n          {search_image_result.title}\n        </a>\n      </p>\n\n      <p>\n        <a href=\"{search_image_result.link}\">\n          <img\n            alt=\"{search_image_result.title}\"\n            src=\"{search_image_result.thumbnail}\"\n          />\n        </a>\n      </p>\n    '\n  end.join(\"<br>\")\n\n  handles.each do |handle|\n    to = User.find(handle)\n\n    next unless to\n\n    message = Message.create!(\n      from: from,\n      to: to,\n      subject: subject,\n      body: body,\n    )\n\n    Notification.create!(\n      from: from,\n      to: to,\n      subject: subject,\n      path: \"/users/{to.id}/messages/{message.id}/body\",\n      sound: :default,\n      thread_id: :google,\n      collapse_key: :google,\n    )\n  end\nend\n\n\"google {Date.today}\"",
    "created_at": "2025-08-28T15:52:31.351Z",
    "updated_at": "2025-09-12T07:01:05.178Z",
    "name": "vincent: google"
  },
  {
    "id": 62,
    "user_id": 1,
    "input": "from = User.find!(\"dorian\")\nhandles = [\"marie-odile\"]\nday = Date.today.to_string\nopen_ai_api_key = Datum.value!(\"open_ai_api_key\")\nmodel = Datum.value!(\"model\")\n\nresponse = Http.post(\n  \"https://api.openai.com/v1/chat/completions\",\n  headers: {\n    authorization: \"Bearer {open_ai_api_key}\",\n    \"content-type\": \"application/json\"\n  },\n  body: {\n    model: model,\n    messages: [\n      { role: :system, content: \"give me a random positive sentence in french, without quotes, without authors, just the sentence\" },\n      { role: :system, content: \"random seed {(1..100_000).sample}\" },\n    ],\n  }.to_json,\n)\n\nsubject = \"phrase positive {day}\"\nbody = Json.parse(response.body).choices.first.message.content\n\nhandles.each do |handle|\n  to = User.find(handle)\n\n  next unless to\n\n  message = Message.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    body: body,\n  )\n\n  Notification.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    body: body,\n    path: \"/users/{to.id}/messages/{message.id}/body\",\n    sound: :default,\n    thread_id: :positive,\n    collapse_key: :positive,\n  )\nend\n\nsubject",
    "created_at": "2025-05-16T19:17:48.312Z",
    "updated_at": "2025-09-12T07:00:17.500Z",
    "name": "marie-odile: positive"
  },
  {
    "id": 122,
    "user_id": 1,
    "input": "from = User.find!(\"dorian\")\nhandles = [\"vincent\", \"dorian\"]\nopen_ai_api_key = Datum.value!(\"open_ai_api_key\")\nmodel = Datum.value!(\"model\")\nlimit = 10\n\nquestions_response = Http.post(\n  \"https://api.openai.com/v1/chat/completions\",\n  headers: {\n    authorization: \"Bearer {open_ai_api_key}\",\n    \"content-type\": \"application/json\"\n  },\n  body: {\n    model: model,\n    response_format: {\n      type: \"json_schema\",\n      json_schema: {\n        name: \"questions\",\n        schema: {\n          type: \"object\",\n          properties: {\n            questions: {\n              type: \"array\",\n              minItems: limit,\n              maxItems: limit,\n              items: {\n                type: \"object\",\n                properties: {\n                  question: { type: \"string\" },\n                  answer: { type: \"string\" }\n                },\n                required: [\"question\", \"answer\"],\n                additionalProperties: false\n              }\n            }\n          },\n          required: [\"questions\"],\n          additionalProperties: false\n        }\n      }\n    },\n    messages: [\n      { role: :system, content: \"give me a json of {limit} random difficult questions and with one word answers, in french\" },\n      { role: :system, content: \"random seed {(1..100_000).sample}\" },\n    ],\n  }.to_json,\n)\n\nquestions = Json.parse(Json.parse(questions_response.body).choices.first.message.content).questions\n\nquestions_subject = \"questions {Date.today}\"\nanswers_subject = \"réponses {Date.today}\"\n\nquestions_body = questions.map do |question|\n  \"<p>{question.question}</p>\"\nend.join(\"\\n\")\n\nanswers_body = questions.map do |question|\n  \"<p>{question.question} {question.answer}</p>\"\nend.join(\"\\n\")\n\nhandles.each do |handle|\n  to = User.find(handle)\n\n  next unless to\n\n  questions_message = Message.create!(\n    from: from,\n    to: to,\n    subject: questions_subject,\n    body: questions_body,\n  )\n  \n  Message.create!(\n    from: from,\n    to: to,\n    subject: answers_subject,\n    body: answers_body,\n  )\n\n  Notification.create!(\n    from: from,\n    to: to,\n    subject: questions_subject,\n    path: \"/users/{to.id}/messages/{questions_message.id}/body\",\n    sound: :default,\n    thread_id: :questions,\n    collapse_key: :questions,\n  )\nend\n\nquestions_subject",
    "created_at": "2025-09-06T11:12:19.470Z",
    "updated_at": "2025-09-12T07:01:03.309Z",
    "name": "vincent: questions"
  },
  {
    "id": 126,
    "user_id": 1,
    "input": "from = User.find!(\"dorian\")\nhandles = [\"dorian\"]\nopen_ai_api_key = Datum.value!(\"open_ai_api_key\")\nmodel = Datum.value!(\"model\")\n\nresponse = Http.post(\n  \"https://api.openai.com/v1/chat/completions\",\n  headers: {\n    authorization: \"Bearer {open_ai_api_key}\",\n    \"content-type\": \"application/json\"\n  },\n  body: {\n    model: model,\n    messages: [\n      {\n        role: :system,\n        content: \"provide a random concise historical fact for the date {Date.today} in french\"\n      },\n      { role: :system, content: \"random seed {(1..100_000).sample}\" },\n    ],\n  }.to_json,\n)\n\nsubject = \"history {Date.today}\"\nbody = Json.parse(response.body).choices.first.message.content\n\nhandles.each do |handle|\n  to = User.find(handle)\n  \n  next unless to\n\n  message = Message.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    body: body\n  )\n\n  Notification.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    body: body,\n    path: \"/users/{to.id}/messages/{message.id}/body\",\n    sound: :default,\n    thread_id: :history,\n    collapse_key: :history\n  )\nend\n\nsubject",
    "created_at": "2025-09-06T12:36:47.776Z",
    "updated_at": "2025-09-12T07:00:49.985Z",
    "name": "dorian: history"
  },
  {
    "id": 116,
    "user_id": 1,
    "input": "from = User.find!(\"dorian\")\n\nbirthdays = Datum.value!(\"birthdays\")\nbirthdays_to_users = Datum.value!(\"birthdays_to_users\")\n\nbirthdays_to_users.each do |handle, names|\n  to = User.find(handle)\n\n  next unless to\n\n  names.each do |name|\n    birthday = birthdays[name]\n\n    next unless birthday\n\n    birthday = Date.new(birthday)\n    birthday_this_year = birthday.change(year: Date.year)\n\n    if birthday_this_year == Date.today\n      age = Date.year - birthday.year\n      age_string = age == 1 ? \"1 an\" : \"{age} ans\"\n\n      subject = \"c'est l'anniversaire de {name} : {age_string}\"\n      body = \"la date de naissance est {birthday}\"\n\n      message = Message.create!(\n        from: from,\n        to: to,\n        subject: subject,\n        body: body,\n      )\n    \n      Notification.create!(\n        from: from,\n        to: to,\n        subject: subject,\n        body: body,\n        path: \"/users/{to.id}/messages/{message.id}/body\",\n        sound: :default,\n        thread_id: :birthdays,\n        collapse_key: :birthdays,\n      )\n    end\n  end\nend\n\n\"birthdays {Date.today}\"",
    "created_at": "2025-08-31T13:57:25.179Z",
    "updated_at": "2025-09-12T07:00:04.636Z",
    "name": "dorian: birthdays"
  },
  {
    "id": 123,
    "user_id": 1,
    "input": "from = User.find!(\"dorian\")\nhandles = [\"dorian\"]\nopen_ai_api_key = Datum.value!(\"open_ai_api_key\")\nmodel = Datum.value!(\"model\")\n\nresponse = Http.post(\n  \"https://api.openai.com/v1/chat/completions\",\n  headers: {\n    authorization: \"Bearer {open_ai_api_key}\",\n    \"content-type\": \"application/json\"\n  },\n  body: {\n    model: model,\n    messages: [\n      { role: :system, content: \"give me a random motivational quote in french, just the quote\" },\n      { role: :system, content: \"random seed {(1..100_000).sample}\" },\n    ],\n  }.to_json,\n)\n\nsubject = \"citation {Date.today}\"\nbody = Json.parse(response.body).choices.first.message.content\n\nhandles.each do |handle|\n  to = User.find(handle)\n  next unless to\n\n  message = Message.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    body: body\n  )\n\n  Notification.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    body: body,\n    path: \"/users/{to.id}/messages/{message.id}/body\",\n    sound: :default,\n    thread_id: :quote,\n    collapse_key: :quote\n  )\nend\n\nsubject",
    "created_at": "2025-09-06T12:06:17.077Z",
    "updated_at": "2025-09-12T07:00:27.704Z",
    "name": "dorian: quote"
  },
  {
    "id": 125,
    "user_id": 1,
    "input": "from = User.find!(\"dorian\")\nhandles = [\"dorian\"]\nopen_ai_api_key = Datum.value!(\"open_ai_api_key\")\nmdeol = Datum.value!(\"model\")\n\nresponse = Http.post(\n  \"https://api.openai.com/v1/chat/completions\",\n  headers: {\n    authorization: \"Bearer {open_ai_api_key}\",\n    \"content-type\": \"application/json\"\n  },\n  body: {\n    model: model,\n    response_format: {\n      type: \"json_schema\",\n      json_schema: {\n        name: \"dictionary\",\n        schema: {\n          type: \"object\",\n          properties: {\n            word: { type: \"string\" },\n            definition: { type: \"string\" },\n            example: { type: \"string\" }\n          },\n          required: [\"word\", \"definition\", \"example\"],\n          additionalProperties: false\n        }\n      }\n    },\n    messages: [\n      {\n        role: :system,\n        content: \"give me a random word in french with its definition in french and an example sentence in french, no dot at the end\"\n      },\n      { role: :system, content: \"random seed {(1..100_000).sample}\" },\n    ],\n  }.to_json,\n)\n\nsubject = \"dictionary {Date.today}\"\ndictionary = Json.parse(Json.parse(response.body).choices.first.message.content)\n\nnotification_body = dictionary.word\nmessage_body = \"{dictionary.word}. {dictionary.definition}. {dictionary.example}.\"\n\nhandles.each do |handle|\n  to = User.find(handle)\n  next unless to\n\n  message = Message.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    body: message_body\n  )\n\n  Notification.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    body: notification_body,\n    path: \"/users/{to.id}/messages/{message.id}/body\",\n    sound: :default,\n    thread_id: :dictionary,\n    collapse_key: :dictionary\n  )\nend\n\nsubject",
    "created_at": "2025-09-06T12:21:07.532Z",
    "updated_at": "2025-09-12T07:00:53.332Z",
    "name": "dorian: dictionary"
  },
  {
    "id": 64,
    "user_id": 1,
    "input": "from = User.find!(\"dorian\")\nhandles = [\"vincent\"]\nsubject = \"twitter humour {Date.today}\"\nmax_results = 20\ntwitter_api_key = Datum.value!(\"twitter_api_key\")\ntwitter_api_key_secret = Datum.value!(\"twitter_api_key_secret\")\nquery = \"(humour OR drôle OR marrant) lang:fr has:images -is:retweet -is:reply\"\n\ntoken_response = Http.post(\n  \"https://api.twitter.com/oauth2/token\",\n  username: twitter_api_key,\n  password: twitter_api_key_secret,\n  query: { grant_type: :client_credentials }\n)\n\ntoken_body = token_response.body\ntoken_json = Json.parse(token_body)\n\ntwitter_access_token = token_json.access_token\n\nsearch_response = Http.get(\n  \"https://api.twitter.com/2/tweets/search/recent\",\n  headers: {\n    authorization: \"Bearer {twitter_access_token}\"\n  },\n  query: {\n    query: query,\n    \"tweet.fields\": \"id,text,lang,created_at,attachments\",\n    \"expansions\": \"attachments.media_keys\",\n    \"media.fields\": \"media_key,type,url,preview_image_url\",\n    max_results: max_results\n  }\n)\n\nsearch_body = search_response.body\nsearch_json = Json.parse(search_body)\n\nbody = search_json.data.map do |tweet|\n  media_keys = tweet.dig(:attachments, :media_keys)\n  media = search_json.includes.media\n\n  next unless media_keys\n  \n  media = media_keys.map { |media_key| media.detect { |media| media.media_key == media_key } }.compact\n  urls = media.map { |media| media[:url] or media[:preview_image_url] }.compact\n\n  next if urls.none?\n\n  '\n    <p>{tweet.text}</p>\n\n    {urls.map { |url| '<p><a href=\"{url}\"><img src=\"{url}\" /></a></p>' }.join}\n  '\nend.join\n\nhandles.each do |handle|\n  to = User.find(handle)\n\n  next unless to\n\n  message = Message.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    body: body,\n  )\n\n  Notification.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    path: \"/users/{to.id}/messages/{message.id}/body\",\n    sound: :default,\n    thread_id: :twitter,\n    collapse_key: :twitter,\n  )\nend\n\nsubject",
    "created_at": "2025-05-16T19:18:54.488Z",
    "updated_at": "2025-09-12T08:00:08.914Z",
    "name": "vincent: twitter"
  },
  {
    "id": 118,
    "user_id": 1,
    "input": "from = User.find(\"dorian\")\nhandles = [\"dorian\"]\n\naddress = \"49 rue de grandvilliers, 60360 crèvecœur-le-grand\"\ngoogle_geocoding_api_key = Datum.value!(\"google_geocoding_api_key\")\nopen_weather_map_api_key = Datum.value!(\"open_weather_map_api_key\")\nopen_ai_api_key = Datum.value!(\"open_ai_api_key\")\nmodel = Datum.value!(\"model\")\n\ngeocoding_response = Http.get(\n  \"https://maps.googleapis.com/maps/api/geocode/json\",\n  query: {\n    address: address,\n    key: google_geocoding_api_key,\n  },\n)\n\nlocation = Json.parse(geocoding_response.body).results.first.geometry.location\n\nlatitude = location.lat\nlongitude = location.lng\n\nweather_response = Http.get(\n  \"https://api.openweathermap.org/data/3.0/onecall\",\n  query: {\n    lat: latitude,\n    lon: longitude,\n    appid: open_weather_map_api_key,\n    units: :metric,\n  },\n)\n\nai_response = Http.post(\n  \"https://api.openai.com/v1/chat/completions\",\n  headers: {\n    authorization: \"Bearer {open_ai_api_key}\",\n    \"content-type\": \"application/json\"\n  },\n  body: {\n    model: model,\n    messages: [\n      { role: :system, content: 'i queried the weather in metric units for {address} today' },\n      { role: :system, content: 'here is the response from openweather api' },\n      { role: :user, content: weather_response.body },\n      { role: :system, content: 'give me a one sentence short summary of the weather for today in french' },\n    ],\n  }.to_json,\n)\n\nsubject = \"météo {Date.today}\"\nbody = Json.parse(ai_response.body).choices.first.message.content\n\nhandles.each do |handle|\n  to = User.find(handle)\n\n  next unless to\n\n  message = Message.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    body: body,\n  )\n\n  Notification.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    body: body,\n    path: \"/users/{to.id}/messages/{message.id}/body\",\n    sound: :default,\n    thread_id: :weather,\n    collapse_key: :weather,\n  )\nend\n\nsubject",
    "created_at": "2025-09-01T20:23:36.967Z",
    "updated_at": "2025-09-12T07:01:18.797Z",
    "name": "dorian: weather"
  },
  {
    "id": 59,
    "user_id": 1,
    "input": "from = User.find!(\"dorian\")\nhandles = [\"mom\"]\nday = Date.today.to_string\nopen_ai_api_key = Datum.value!(\"open_ai_api_key\")\nmodel = Datum.value!(\"model\")\n\nresponse = Http.post(\n  \"https://api.openai.com/v1/chat/completions\",\n  headers: {\n    authorization: \"Bearer {open_ai_api_key}\",\n    \"content-type\": \"application/json\"\n  },\n  body: {\n    model: model,\n    messages: [\n      { role: :system, content: 'give me the \"day of ...\" in french for france' },\n      { role: :user, content: \"today is {day}\" },\n      { role: :system, content: \"examples: international women's day, international pi day, bastille day, halloween, mother's day\" },\n      { role: :system, content: 'keep it short, only the \"day of\" as a list separed by <br>' },\n    ],\n  }.to_json,\n)\n\nsubject = \"journée du {day}\"\nmessage_body = Json.parse(response.body).choices.first.message.content\nnotification_body = message_body.substitute(\"<br>\", \"\\n\")\n\nhandles.each do |handle|\n  to = User.find(handle)\n\n  next unless to\n\n  message = Message.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    body: message_body,\n  )\n\n  Notification.create!(\n    from: from,\n    to: to,\n    subject: subject,\n    body: notification_body,\n    path: \"/users/{to.id}/messages/{message.id}/body\",\n    sound: :default,\n    thread_id: :day,\n    collapse_key: :day,\n  )\nend\n\nsubject",
    "created_at": "2025-05-16T19:15:53.577Z",
    "updated_at": "2025-09-12T06:00:16.234Z",
    "name": "mom: day"
  },
  {
    "id": 128,
    "user_id": 1,
    "input": "from = User.find!(\"dorian\")\nhandles = [\"dorian\"]\nsubject = \"generate {Time.now}\"\nopen_ai_api_key = Datum.value!(\"open_ai_api_key\")\nmodel = Datum.value!(\"model\")\n\nif Time.hour >= 6 and Time.hour < 23\n  response = Http.post(\n    \"https://api.openai.com/v1/chat/completions\",\n    headers: {\n      authorization: \"Bearer {open_ai_api_key}\",\n      \"content-type\": \"application/json\"\n    },\n    body: {\n      model: model,\n      response_format: {\n        type: :json_schema,\n        json_schema: {\n          name: :input,\n          strict: true,\n          schema: {\n            type: :object,\n            properties: {\n              name: {\n                type: :string\n              },\n              input: {\n                type: :string\n              },\n              schedules: {\n                type: :array,\n                items: {\n                  type: :object,\n                  properties: {\n                    starts_at: {\n                      type: :string,\n                      format: \"date-time\"\n                    },\n                    interval: {\n                      type: :string,\n                      enum: Schedule.intervals\n                    }\n                  },\n                  required: [:starts_at, :interval],\n                  additionalProperties: false\n                }\n              }\n            },\n            required: [:name, :input, :schedules],\n            additionalProperties: false\n          }\n        }\n      },\n      messages: [\n        { role: :system, content: \"give me a json of a new random useful orginal program with its optional schedules\" },\n        { role: :system, content: \"random seed {(1..100_000).sample}\" },\n        { role: :system, content: \"here are my programs in json\" },\n        { role: :user, content: Current.programs.to_json(pretty: true) },\n      ],\n    }.to_json,\n  )\n  program = Json.parse(Json.parse(response.body).choices.first.message.content)\n  \n  body = \"<p><b>{program.name}</b></p>\n  \n  <pre>\n  {program.input}\n  </pre>\n  \n  <ul>{program.schedules.map { |schedule| \"<li>{schedule.interval}: {schedule.starts_at}</li>\" }.join}</ul>\"\n  \n  handles.each do |handle|\n    to = User.find(handle)\n  \n    next unless to\n  \n    message = Message.create!(\n      from: from,\n      to: to,\n      subject: subject,\n      body: body,\n    )\n  \n    Notification.create!(\n      from: from,\n      to: to,\n      subject: subject,\n      path: \"/users/{to.id}/messages/{message.id}/body\",\n      sound: :default,\n      thread_id: :generate,\n      collapse_key: :generate,\n    )\n  end\nend\n\nsubject",
    "created_at": "2025-09-07T15:16:30.463Z",
    "updated_at": "2025-09-12T18:00:43.729Z",
    "name": "dorian: generate"
  }
]
